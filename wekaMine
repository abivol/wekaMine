#!/usr/bin/env groovy 

import durbin.weka.* 
import durbin.util.*

err = System.err // sugar

// Get the command line options, print help if needed. 
options = ParseOptions(args)

// Expand the configuration file into a list of experiments. 
experiments = new WekaMineConfig(options.config)


err.println ""
// Create output files, a summary output, a features output, and a samples output.
fileOut = "${options.output}${options.experimentRange}.summary.csv" as String
err.println "Creating output file $fileOut"
out = new File(fileOut)

featuresOut = "${options.output}${options.experimentRange}.features.csv" as String
err.println "Creating features output file $featuresOut"
fout = new File(featuresOut)

samplesOut = "${options.output}${options.experimentRange}.samples.csv" as String
err.println "Creating samples output file $samplesOut"
sout = new File(samplesOut)
err.println ""

// Read the data (expression, CNV, whatever) and the clinical from tab delimited files
data = WekaMine.readNumericFromTable(options.data)
clinical = WekaMine.readNumericFromTable(options.clinical)

// Perform each experiment described in the experiment spec...
//experiments[options.experimentRange].eachWithIndex{exp,idx-> 
experiments[options.experimentRange].eachWithIndex{exp,idx-> 
	jobIdx = idx+options.experimentRange.getTo()
	err.println "Experiment: $jobIdx"
	try{
	
		// Creates a wekaMine pipeline...
		pipeline = new WekaMine(data,clinical,exp,experiments.params)		
		
		// Combines data and single class attribute from clinical into one set of instances...
		instances = pipeline.createInstancesFromDataAndClinical(data,clinical,exp.classAttribute)	

		// Clean up instances:
		// * remove useless attributes
		// * if not allowed, remove instances with negative class values
		// * remove instances with missing class values	
		instances = pipeline.cleanUpInstances(instances)


		// Discretize the class attribute...
		instances = pipeline.discretizeClassAttribute(instances)	

		// Create an attribute selected classifier from the given experiment description..
		asClassifier = pipeline.createAttributeSelectedClassifier()
						
		// Perform the cross validation
		err.println "AttSel:  ${exp.attrEvalStr} numAttrs: ${exp.numAttributes}"
		err.println "Classifier: ${exp.classifierStr}"
		err.print "Crossvalidating (${experiments.params.cvFolds} folds) model on ${instances.numInstances()} instances ..."
		def eval = pipeline.crossValidateModel(asClassifier,instances,
			experiments.params.cvFolds,new Random(experiments.params.cvSeed))
		err.println "done. AUC=${eval.weightedAreaUnderROC()}"
	  err.println "=========================================="
	
		pipeline.appendSummary(out,jobIdx,instances)
		pipeline.appendFeatures(fout,jobIdx,instances,options.maxFeaturesOut as Integer)
		pipeline.appendSamples(sout, jobIdx,instances)
			
	}catch (Exception e){
		err.println e
		// Save info about exception..
	}
}



//============================================================================
// 


/****************************************************
* Parse the command line options, checking validity, printing help if needed. 
*/ 
def ParseOptions(args){
	parser = new Parser(description: '''
	 wekaMine takes a tab delimited data file in attributes (rows) x samples (cols) format, 
	 and a clinical file, also in attributes (rows) x samples (cols) format, and evaluates 
	 the set of experiments specified in an experimental configuration file.  Classification is 
	 performed on the samples that occur in both the data and clinical file (intersection). 
	 A list of summary lines in CSV format will be APPENDED to the end of the output file.  
	 Since this will often be run in a cluster setting with many jobs appending to the same 
	 file, the heading is not normally written out.  Run this script with the -H option to 
	 just output heading to stdout.  

	 Instances with missing class values are removed.   Attributes that do not vary at all 
	 are removed.  Instances with negative class values are optionally removed.  

	 The actual experiments and experimental options are provided by the config file (-c). 
	 Documentation for this config file can be found here:  

	 https://cancer2.cse.ucsc.edu/mediawiki/index.php/WekaClassifierConfig

	 Note that the config file can specify a number of attributes to use in attribute 
	 selection, or -1 to auto-select (the details of which varies from attribute selection 
	 algorithm to attribute selection algorithm). The config file option actually determines 
	 how many attributes the classifier sees.  The -m/maxFeaturesOut option merely determines 
	 the maximum number of selected attributes (and their scores) to save in the output and 
	 does not affect what attributes the classifier will see. 

	Written by: James Durbin (kdurbin@ucsc.edu)

	 Example:

	 wekaMine  \\
	 -d data/paradigm_results.txt -i data/collisonclinical.small.tab \\
	 -c exp/cfgExample2.txt -r 0,19 -o results/expout.csv

	''');

	parser.with{

	  required 'o','output',[description: 'File where output should go. Generates three files *.summary.csv, *.features.csv, and *.samples.csv']
	  required 'c','config',[description: 'Configuration file']  
	  required 'd','data', [description: 'Data file in attribute (row) by samples (col) format.']
	  required 'i','clinical', [description: 'Clinical file in attribute (row) by samples (col) format.']

	  optional 'm','maxFeaturesOut',[default: 0,description: "Maximum number of ranked features to output from cross-validation or full-set if classifier is 'None'"]

	  optional 'r','experimentRange',[default: "0,-1", description: 'Range of experiments to run (e.g. -r 54,67, mainly for cluster splits)',
			// Convert it to a proper range. Default is all inclusive range. 
			validate:{								
		 		experimentStart = (it.split(","))[0] as int
		 		experimentEnd = (it.split(","))[1] as int 
			  range = (experimentStart..experimentEnd)
				return(range)
			}]			
		
		flag 'H','heading',[default:false,description: 'Write out heading for summary.csv.',
		validate:{
			if (it){
				println WekaMineResults.getFormattedSummaryHeading()
				System.exit(1)		
			}
		}]
	  flag 'h','help',[default:false,description: 'Print script help.']
	}

	def options
	try{
	  options = parser.parse(args)
	}catch(Exception e){
	  System.err << parser.usage
	  System.exit(1)
	}	
	
	return(options)
}
